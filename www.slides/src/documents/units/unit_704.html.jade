---cson
layout: 'deck_unit'
title: "Marr’s Threefold Distinction"
tags: []
description: """
  Marr helpfully distinguishes computational description (What is the thing for and how does it achieve this?)
  from representations and algorithms (How are the inputs and outputs represented, and how is the transformation accomplished?)
  and from the hardware implementation (How are the  representations and algorithms physically realised?)
  """
---

include ../../../fragments/unit_mixins
include ../../../fragments/origins_mixins


+slide_middle
  p.center.handout.show If I apply the Teleological Stance successfully, do I thereby come to know a fact about the goal of an action?
  .notes: :t
    To answer this question, we need to get beyond the Teleological Stance
    and consider the representations and algorithms that underpin it.
    Let me explain.
  .slide
    .notes: :t
      Consider Csibra & Gergely’s own answer, which is ‘Yes!’
    p.em-above.notes.show: :t
      ‘when taking the teleological stance one-year-olds apply the same
      inferential principle of rational action that drives everyday mentalistic
      reasoning about intentional actions in adults’ 
    p.right.grey-text (György Gergely and Csibra 2003; cf. Csibra, Bíró, et al. 2003; Csibra and Gergely 1998: 259)
    

//- TODO : replace with   +marrDistinction({step:false, handout:false})


+slide_middle
  .handout: :t
    \citet[p.~22ff]{Marr:1982kx} distinguishes:
  .handout: :t
    \begin{itemize}
  .handout: :t
    \item computational description---What is the thing for and how does it achieve this?
  .handout: :t
    \item representations and algorithms---How are the inputs and outputs represented, and how is the transformation accomplished?
  .handout: :t
    \item hardware implementation---How are the representations and algorithms physically realised?
  .handout: :t
    \end{itemize}
  .notes: :t
    One possibility is to appeal to David Marr’s famous three-fold distinction
    bweteen levels of description of a system: the computational theory, the 
    representations and algorithm, and the hardware implementation.  
  .notes: :t
    This is easy to understand in simple cases.
    To illustrate, consider a GPS locator.
    It receives information from four satellites and tells you where on Earth the device is.
  .notes: :t
    There are three ways in which we can characterise this device.
  .slide
    .computational.hem-around
      p 1. computational description
      .notes: :t
        First, we can explain how in theory it is possible to infer the 
        device’s location from it receives from satellites.
        This involves a bit of maths: given time signals from four different satellites,
        you can work out what time it is and how far you are away from each
        of the satellites.
        Then, if you know where the satellites are and what shape the Earth is,
        you can work out where on Earth you are.
      .slide
        p.indent -- What is the thing for and how does it achieve this?
      .notes: :t
        The computational description tells us what the GPS locator does and 
        what it is for.
        It also establishes the theoretical possibility of a GPS locator.
      .notes: :t
        But merely having the computational description does not enable you to build 
        a GPS locator, nor to understand how a particular GPS locator works.
        For that you also need to identify representations and alogrithms ...
  .slide
    .rep-and-alg.hem-around
      p 2. representations and algorithms
      .notes: :t
        At the level of representations and algorthms we specify 
        how the GPS receiver represents the information it receives from the satellites
        (for example, it might in principle be a number, a vector or a time).
        We also specify the algorithm the device uses to compute the time and its location.
        The algorithm will be different from the computational theory: it is a procedure
        for discovering time and location.
        The algorithm may involve all kinds of shortcuts and approximations.
        And, unlike the computational theory, constraints on time, memory and other
        limited resources will be evident.
      .slide
        .notes So an account of the representations and algorithms tells us ...
        p.notes.show.indent -- How are the inputs and outputs represented, and how is the transformation accomplished?
  .slide
    .hardware.hem-around
      p 3. hardware implementation
      .notes: :t
        The final thing we need to understand the GPS locator is a description of the
        hardware in which the algorithm is implemented.  It’s only here that 
        we discover whether the device is narrowly mechanical device, using cogs, say, 
        or an electronic device, or some new kind of biological entity.
    .slide
      p.indent -- How are the  representations and algorithms physically realised?
      .notes: :t
        The hardware implementation tells us how the representations and algorithms are represented physically.
  p.right.grey-text Marr (1992, 22ff)
  .slide
    +blur('p')
    .notes: :t
      How is this relevant to the teleological stance?
      It provides a computational description of goal ascription.
      (Whereas the Motor Theory provides an account of the representations and algorithms )
  .slide
    +unblur('p')
    +highlight-row('.computational')
    .notes: :t
      The teleological stance  provides a computational description of goal ascription.
  .slide
    +unblur('p')
    +unhighlight-row('.computational')
    +highlight-row('.rep-and-alg')
    .notes: :t
      For deeper insight into goal ascription, we need an account of representations and 
      algorithms.
    .notes: :t
      Compare our research on infants’ abilities concerning physical objects.
      Spelke’s principles of object perception provide a computational description
      of infants’ abilities to segment, etc.
      But to understand the nature of these abilities and their relation to knowledge,
      and to explain the otherwise puzzling patterns of development, we needed to 
      identify representations and alogrithms. 
      (We did this by appeal to the operations of a system of object indexes.)



+teleologicalStanceSlide({step:false, handout:false})
  .notes: :t
    The teleological stance is a computational description.
    What’s the algorithm?


+slide_middle
  p.notes.handout.show: :t
    ‘when taking the teleological stance one-year-olds apply the same
    inferential principle of rational action that drives everyday mentalistic
    reasoning about intentional actions in adults’ 
  .notes.handout.ctd (\citealp{Gergely:2003gb}; compare \citealp{Csibra:2003jv}, \citealp[p.~259]{Csibra:1998cx} )
  p.right.grey-text (György Gergely and Csibra 2003; cf. Csibra, Bíró, et al. 2003; Csibra and Gergely 1998: 259)



+slide_middle
  .notes: :t
    Csibra and Gergely seem aware that this would make the Teleological Stance quite
    complex to apply ...
  p.handout.notes.show
    span `Such calculations require 
    span.highlight detailed knowledge of biomechanical factors
    span  that determine the motion capabilities and energy expenditure of agents.  
    span.step2.hide
      span However, in the absence of such knowledge, one can appeal to 
      span.heuristics heuristics 
    span.step3.hide
      span  that approximate the results of these calculations on 
      span the basis of knowledge in other domains that is certainly available to young infants. 
    p.step4.hide
      span For example, the length of pathways can be assessed by 
      span geometrical calculations
      span , taking also into account some physical factors 
      span (like the  
      span.solidity impenetrability of solid objects
      span ). 
    span.step5.hide
      span Similarly, the fewer steps an action sequence takes, the less effort it might require, 
      span and so 
      span infants’ 
      span.number numerical competence
      span  can also contribute to efficiency evaluation.’
  p.right.grey-text Csibra & Gergely, forthcoming ms p. 8
  .slide
    +invert('.highlight')
  .slide
    +show('.step2')
  .slide
    +invert('.heuristics')
    .notes What heuristics.
  .slide
    +show('.step3')
  .slide
    +show('.step4')
  .slide
    +highlight('.solidity', 'red')
    .notes: :t
      Csibra and Gergely’s newer proposal seems to assume the inferential integration
      of core systems.  
      But principles governing object indexes are not typically available for 
      general reasoning.
  .slide
    +show('.step5')
  .slide
    +highlight('.number', 'red')
    

+slide_middle
  p.center Is there an alternative?